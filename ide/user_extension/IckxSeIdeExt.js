/** ___     _           ____       ___    _      _____      _
 * |_ _|___| | ____  __/ ___|  ___|_ _|__| | ___| ____|_  _| |_
 *  | |/ __| |/ /\ \/ /\___ \ / _ \| |/ _` |/ _ \  _| \ \/ / __|
 *  | | (__|   <  >  <  ___) |  __/| | (_| |  __/ |___ >  <| |_
 * |___\___|_|\_\/_/\_\|____/ \___|___\__,_|\___|_____/_/\_\\__|
 *
 * @category	Selenium-IDE Extension
 * @author		wakaba <wakabadou@gmail.com>
 * @copyright	2015- Wakabadou honpo (http://www.wakabadou.net/) / Project ICKX (http://www.ickx.jp/)
 * @license		http://opensource.org/licenses/MIT The MIT License
 * @varsion		1.0.0
 * @see			ASCII Art Generated by http://patorjk.com/software/taag/
 * 				Font Name: Ivrit
 *
 * !!attention!!
 * This extension is exclusive SelBlocks.
 *
 * Recommendation Plug-ins:
 *   Favorites (Selenium IDE) :: Add-ons for Firefox
 *     https://addons.mozilla.org/en-US/firefox/addon/favorites-selenium-ide/
 *
 *   Stored Variables (Selenium IDE) :: Add-ons for Firefox
 *     https://addons.mozilla.org/en-US/firefox/addon/stored-variables-viewer-seleni/
 *
 *   File Logging (Selenium IDE) :: Add-ons for Firefox
 *     https://addons.mozilla.org/en-US/firefox/addon/file-logging-selenium-ide/
 *
 *   ScreenShot on Fail (Selenium IDE) :: Add-ons for Firefox
 *     https://addons.mozilla.org/en-US/firefox/addon/screenshot-on-fail-selenium/
 *
 *   Test Results (Selenium IDE) :: Add-ons for Firefox
 *     https://addons.mozilla.org/en-US/firefox/addon/test-results-selenium-ide/
 *
 *   Log Search Bar (Selenium IDE) :: Add-ons for Firefox
 *     https://addons.mozilla.org/en-US/firefox/addon/log-search-bar-selenium-ide/
 */

//===================================//
// Project ICKX Selenium-IDE Library //
//===================================//
/**
 * @var	IckxSeIdeLib	Project ICKX Selenium-IDE Library
 */
var IckxSeIdeLib = classCreate();
objectExtend(IckxSeIdeLib.prototype, {
	//----------------------------------
	//Extend methods
	//----------------------------------
	/**
	 * initializer
	 */
	initialize : function () {},

	//----------------------------------
	//Support Store
	//----------------------------------
	/**
	 * @var	Object	IckxSeIdeLib内部用バリューストア
	 * bool				inSilentMode	: info log表示抑制フラグ
	 * CommandFacgtory	commandFactory	: コマンドファクトリーインスタンスキャッシュ
	 */
	storedVars : {
		inSilentMode	: false,
		commandFactory	: null
	},

	//----------------------------------
	//CSV Support
	//----------------------------------
	/**
	 * CSVファイルをロードし、配列として返します。
	 *
	 * @param	String	file_path	読込むCSVファイルのパス フルパスまたはXPATH形式のパスを指定してください。
	 * @param	object	options		読込オプション
	 * @return	array	CSVデータ
	 */
	csvLoad : function (file_path, options) {
		//==================================
		//ファイルパスの正規化
		//==================================
		//パスセパレータを'/'に統一
		var file_path = file_path.replace(/\\/g, '/');

		//一旦XPATHを解除
		file_path = file_path.replace(/^file:\/\//, '');

		//相対パスだった場合、現在実行中のテストケースパスを追加する
		if (!file_path.match(/^(?:[a-zA-Z]:\/|\/)/)) {
			file_path = IckxSeIdeLib.prototype.getCurrentTestCaseFolder().replace(/\\/g, '/') + '/'+ file_path;
		}

		//XPATH化
		file_path = ('file:/'+ file_path).replace(/file:\/{2,}/, 'file:/');

		//==================================
		//XHRを利用したファイル取得
		//==================================
		//xhrを利用してファイルを取得する
		var xhr = this.getXMLHttpRequest();
		if (!xhr) {
			throw this.buildErrMsg('お使いのブラウザではXMLHttpRequestを利用できません。', e);
		}

		xhr.open('GET', file_path, false);
		try {
			xhr.send(null);
		} catch(e) {
			throw this.buildErrMsg('対象のファイルが無いか、開く事ができません。path:'+ file_path, e);
		}

		//==================================
		//CSV解析と返却
		//==================================
		return this.purseCsv(xhr.responseText, options);
	},

	/**
	 * ブラウザに合わせたXMLHttpRequest Instanceを返します。
	 *
	 * @return	XMLHttpRequest	ブラウザごとのXMLHttpRequest
	 */
	getXMLHttpRequest : function () {
		var e = null;
		try {
			if(window.ActiveXObject) {
				try {
					return new ActiveXObject("Msxml2.XMLHTTP");
				} catch(e) {
					return new ActiveXObject("Microsoft.XMLHTTP");
				}
			}

			if (window.XMLHttpRequest) {
				return new XMLHttpRequest;
			}
		} catch(e) {}
		throw this.buildErrMsg('お使いのブラウザではXMLHttpRequestを利用できません。', e);
	},

	/**
	 * CSVテキストをパースします。
	 *
	 * @param	String	text		パースするCSVテキスト
	 * @param	object	options		読込オプション
	 * @return	array	パースしたCSV文字の配列 常に2次元の配列となる
	 */
	purseCsv : function (text, options) {
		//==================================
		//optionの初期化
		//==================================
		//行コメントの設定
		var row_comment	= null;

		//空行のスキップ
		var skip_empty	= false;

		//区切り文字 指定なしの場合は , を指定したものとみなす
		var delimiter	= ',';

		//囲み文字 指定なしの場合は " を指定したものとみなす
		var enclosure	= '"';

		//囲み文字のエスケープ文字 指定なしの場合は " を指定したものとみなす
		var escape		= '"';

		//プリプロセッサ 指定なしの場合はnullを指定したものとみなす
		var preprocess	= null;

		//一括設定
		if (options != undefined && options != null) {
			'row_comment'	in options	? row_comment	= options.row_comment : null;
			'skip_empty'	in options	? skip_empty	= options.skip_empty : null;
			'delimiter'		in options	? delimiter		= options.delimiter : null;
			'enclosure'		in options	? enclosure		= options.enclosure : null;
			'escape'		in options	? escape		= options.escape : null;
			'preprocess'	in options	? preprocess	= options.preprocess : null;
		}
		var crlf = '(?:\r?\n|\r)';

		//==================================
		//主処理
		//==================================
		var regex_pattern_set = [
			delimiter,
			crlf,
			'[^' + delimiter + enclosure + crlf + '][^' + delimiter + crlf + ']*',
			enclosure +'(?:[^'+ enclosure +']|'+ escape + enclosure +')*'+ enclosure
		];
		var tokenizer = new RegExp(regex_pattern_set.join('|'), 'g');
		var escaped_enclosure	= new RegExp(escape + enclosure, 'g');

		var row					= 0;
		var column				= 0;
		var data				= [[]];
		var in_comment			= false;

		var in_data = false;

		text.replace(tokenizer, function(token) {
			if (column == 0) {
				if (token.charAt(0) == row_comment) {
					in_comment = true;
					return '';
				}

				if (skip_empty && (token == "\r\n" || token == "\r" || token == "\n")) {
					if (in_comment) {
						in_comment = false;
					} else if (in_data) {
						data.push([]);
						++row;
						in_data = false;
					}
					return '';
				}
			}

			switch (token) {
				case delimiter:
					if (in_comment) {
						break;
					}
					data[row].push('');
					++column;
					exist_row = true;
					break;
				case '\r\n': case '\r': case '\n':
					if (in_comment) {
						in_comment = false;
						break;
					}
					data.push([]);
					++row;
					column = 0;
					in_data = false;
					break;
				default:
					if (in_comment) {
						break;
					}
					data[row][column] = token.charAt(0) != enclosure ? token : token.slice(1, -1).replace(escaped_enclosure, enclosure);
					if (preprocess != null) {
						data[row][column] = preprocess(data[row][column]);
					}
					in_data = true;
					break;
			}

			return '';
		});

		if (skip_empty && data[data.length - 1].length == 0) {
			data.pop();
		}

		return data;
	},

	//----------------------------------
	//Path Support
	//----------------------------------
	/**
	 * 現在実行中のテストスイートファイルがあるフォルダパスを返します。
	 *
	 * @return	String	現在実行中のテストスイートファイルがあるフォルダパス
	 */
	getCurrentTestSuiteFolder : function () {
		return editor.app.getTestSuite().file.parent.path;
	},

	/**
	 * 現在実行中のテストスイートファイルのフルパスを返します。
	 *
	 * @return	String	現在実行中のテストスイートファイルのフルパス
	 */
	getCurrentTestSuitePath : function () {
		return editor.app.getTestSuite().file.path;
	},

	/**
	 * 現在実行中のテストスイートファイルのファイル名を返します。
	 *
	 * @return	String	現在実行中のテストスイートファイルのファイル名
	 */
	getCurrentTestSuiteFileName : function () {
		return editor.app.getTestSuite().file.leafName;
	},

	/**
	 * 現在実行中のテストケースファイルがあるフォルダパスを返します。
	 *
	 * @return	String	現在実行中のテストケースファイルがあるフォルダパス
	 */
	getCurrentTestCaseFolder : function () {
		return editor.getTestCase().file.parent.path;
	},

	/**
	 * 現在実行中のテストケースファイルのフルパスを返します。
	 *
	 * @return	String	現在実行中のテストケースファイルのフルパス
	 */
	getCurrentTestCasePath : function () {
		return editor.getTestCase().file.path;
	},

	/**
	 * 現在実行中のテストケースファイルのファイル名を返します。
	 *
	 * @return	String	現在実行中のテストケースファイルのファイル名
	 */
	getCurrentTestCaseFileName : function () {
		return editor.getTestCase().file.leafName;
	},

	/**
	 * 現在実行中のテストを返します。
	 */
	getCurrentTest : function () {
		return currentTest;
	},

	/**
	 * 現在実行中のテストのBaseURLを返します。
	 */
	getBaseURL : function () {
		return currentTest.getBaseURL;
	},

	//----------------------------------
	//mb strings Support
	//----------------------------------
	/**
	 * 整数値で表現されたコードポイントをUTF-8文字に変換する。
	 *
	 * @param   int     code_point  UTF-8文字に変換したいコードポイント
	 * @return  string  コードポイントから作成したUTF-8文字
	 */
	fromChatCodeExt : function (code_point) {
		//サロゲートペア無しの文字の場合
		if (code_point < 0x10000) {
			//素直に処理して返す
			return String.fromCharCode(code_point);
		}

		//サロゲートペア付の文字の場合
		code_point -= 0x10000;
		return String.fromCharCode(0xD800 + (code_point >> 10), 0xDC00 + (code_point & 0x3FF));
	},

	/**
	 * PHPのmb_strwidthと同様の機能を提供します。
	 *
	 * この関数はPHPのmb_strwidth互換です。
	 *
	 * @param	String	str	文字列幅を測りたい文字列
	 * @return	int		文字列幅
	 * @link	http://php.net/manual/ja/function.mb-strwidth.php
	 */
	strWidth : function (str) {
		//============================================
		// 初期化
		//============================================
		var i = 0;
		var str_width = 0;
		var next_char_code = 0;
		var char_code = 0;

		//============================================
		// 文字幅検出
		//============================================
		//一文字ずつ処理
		while (!Number.isNaN((char_code = str.charCodeAt(i++)))) {
			//サロゲートペア対応
			if (0xD800 <= char_code && char_code <= 0xDBFF) {
				next_char_code = str.charCodeAt(i);
				char_code = ((char_code - 0xD800) * 0x400) + (next_char_code - 0xDC00) + 0x10000;
				i++;
			}

			if (0x0 <= char_code && char_code <= 0x10FF) {
				str_width += 1;
			} else if (0x1100 <= char_code && char_code <= 0x115F) {
				str_width += 2;
			} else if (0x1160 <= char_code && char_code <= 0x11A2) {
				str_width += 1;
			} else if (0x11A3 <= char_code && char_code <= 0x11A7) {
				str_width += 2;
			} else if (0x11A8 <= char_code && char_code <= 0x11F9) {
				str_width += 1;
			} else if (0x11FA <= char_code && char_code <= 0x11FF) {
				str_width += 2;
			} else if (0x1200 <= char_code && char_code <= 0x2328) {
				str_width += 1;
			} else if (0x2329 <= char_code && char_code <= 0x232A) {
				str_width += 2;
			} else if (0x232B <= char_code && char_code <= 0x2E7F) {
				str_width += 1;
			} else if (0x2E80 <= char_code && char_code <= 0x2E99) {
				str_width += 2;
			} else if (0x2E9A <= char_code && char_code <= 0x2E9A) {
				str_width += 1;
			} else if (0x2E9B <= char_code && char_code <= 0x2EF3) {
				str_width += 2;
			} else if (0x2EF4 <= char_code && char_code <= 0x2EFF) {
				str_width += 1;
			} else if (0x2F00 <= char_code && char_code <= 0x2FD5) {
				str_width += 2;
			} else if (0x2FD6 <= char_code && char_code <= 0x2FEF) {
				str_width += 1;
			} else if (0x2FF0 <= char_code && char_code <= 0x2FFB) {
				str_width += 2;
			} else if (0x2FFC <= char_code && char_code <= 0x2FFF) {
				str_width += 1;
			} else if (0x3000 <= char_code && char_code <= 0x303E) {
				str_width += 2;
			} else if (0x303F <= char_code && char_code <= 0x3040) {
				str_width += 1;
			} else if (0x3041 <= char_code && char_code <= 0x3096) {
				str_width += 2;
			} else if (0x3097 <= char_code && char_code <= 0x3098) {
				str_width += 1;
			} else if (0x3099 <= char_code && char_code <= 0x30FF) {
				str_width += 2;
			} else if (0x3100 <= char_code && char_code <= 0x3104) {
				str_width += 1;
			} else if (0x3105 <= char_code && char_code <= 0x312D) {
				str_width += 2;
			} else if (0x312E <= char_code && char_code <= 0x3130) {
				str_width += 1;
			} else if (0x3131 <= char_code && char_code <= 0x318E) {
				str_width += 2;
			} else if (0x318F <= char_code && char_code <= 0x318F) {
				str_width += 1;
			} else if (0x3190 <= char_code && char_code <= 0x31BA) {
				str_width += 2;
			} else if (0x31BB <= char_code && char_code <= 0x31BF) {
				str_width += 1;
			} else if (0x31C0 <= char_code && char_code <= 0x31E3) {
				str_width += 2;
			} else if (0x31E4 <= char_code && char_code <= 0x31EF) {
				str_width += 1;
			} else if (0x31F0 <= char_code && char_code <= 0x321E) {
				str_width += 2;
			} else if (0x321F <= char_code && char_code <= 0x321F) {
				str_width += 1;
			} else if (0x3220 <= char_code && char_code <= 0x3247) {
				str_width += 2;
			} else if (0x3248 <= char_code && char_code <= 0x324F) {
				str_width += 1;
			} else if (0x3250 <= char_code && char_code <= 0x32FE) {
				str_width += 2;
			} else if (0x32FF <= char_code && char_code <= 0x32FF) {
				str_width += 1;
			} else if (0x3300 <= char_code && char_code <= 0x4DBF) {
				str_width += 2;
			} else if (0x4DC0 <= char_code && char_code <= 0x4DFF) {
				str_width += 1;
			} else if (0x4E00 <= char_code && char_code <= 0xA48C) {
				str_width += 2;
			} else if (0xA48D <= char_code && char_code <= 0xA48F) {
				str_width += 1;
			} else if (0xA490 <= char_code && char_code <= 0xA4C6) {
				str_width += 2;
			} else if (0xA4C7 <= char_code && char_code <= 0xA95F) {
				str_width += 1;
			} else if (0xA960 <= char_code && char_code <= 0xA97C) {
				str_width += 2;
			} else if (0xA97D <= char_code && char_code <= 0xABFF) {
				str_width += 1;
			} else if (0xAC00 <= char_code && char_code <= 0xD7A3) {
				str_width += 2;
			} else if (0xD7A4 <= char_code && char_code <= 0xD7AF) {
				str_width += 1;
			} else if (0xD7B0 <= char_code && char_code <= 0xD7C6) {
				str_width += 2;
			} else if (0xD7C7 <= char_code && char_code <= 0xD7CA) {
				str_width += 1;
			} else if (0xD7CB <= char_code && char_code <= 0xD7FB) {
				str_width += 2;
			} else if (0xD7FC <= char_code && char_code <= 0xF8FF) {
				str_width += 1;
			} else if (0xF900 <= char_code && char_code <= 0xFAFF) {
				str_width += 2;
			} else if (0xFB00 <= char_code && char_code <= 0xFE0F) {
				str_width += 1;
			} else if (0xFE10 <= char_code && char_code <= 0xFE19) {
				str_width += 2;
			} else if (0xFE1A <= char_code && char_code <= 0xFE2F) {
				str_width += 1;
			} else if (0xFE30 <= char_code && char_code <= 0xFE52) {
				str_width += 2;
			} else if (0xFE53 <= char_code && char_code <= 0xFE53) {
				str_width += 1;
			} else if (0xFE54 <= char_code && char_code <= 0xFE66) {
				str_width += 2;
			} else if (0xFE67 <= char_code && char_code <= 0xFE67) {
				str_width += 1;
			} else if (0xFE68 <= char_code && char_code <= 0xFE6B) {
				str_width += 2;
			} else if (0xFE6C <= char_code && char_code <= 0xFF00) {
				str_width += 1;
			} else if (0xFF01 <= char_code && char_code <= 0xFF60) {
				str_width += 2;
			} else if (0xFF61 <= char_code && char_code <= 0xFFDF) {
				str_width += 1;
			} else if (0xFFE0 <= char_code && char_code <= 0xFFE6) {
				str_width += 2;
			} else if (0xFFE7 <= char_code && char_code <= 0x1AFFF) {
				str_width += 1;
			} else if (0x1B000 <= char_code && char_code <= 0x1B001) {
				str_width += 2;
			} else if (0x1B002 <= char_code && char_code <= 0x1F1FF) {
				str_width += 1;
			} else if (0x1F200 <= char_code && char_code <= 0x1F202) {
				str_width += 2;
			} else if (0x1F203 <= char_code && char_code <= 0x1F20F) {
				str_width += 1;
			} else if (0x1F210 <= char_code && char_code <= 0x1F23A) {
				str_width += 2;
			} else if (0x1F23B <= char_code && char_code <= 0x1F23F) {
				str_width += 1;
			} else if (0x1F240 <= char_code && char_code <= 0x1F248) {
				str_width += 2;
			} else if (0x1F249 <= char_code && char_code <= 0x1F24F) {
				str_width += 1;
			} else if (0x1F250 <= char_code && char_code <= 0x1F251) {
				str_width += 2;
			} else if (0x1F252 <= char_code && char_code <= 0x1FFFF) {
				str_width += 1;
			} else if (0x20000 <= char_code && char_code <= 0x2FFFD) {
				str_width += 2;
			} else if (0x2FFFE <= char_code && char_code <= 0x2FFFF) {
				str_width += 1;
			} else if (0x30000 <= char_code && char_code <= 0x3FFFD) {
				str_width += 2;
			} else if (0x3FFFE <= char_code && char_code <= 0x10FFFF) {
				str_width += 1;
			}
		}

		//============================================
		// 処理の終了
		//============================================
		return str_width;
	},

	/**
	 * PHPのmb_strimwidthと同様の機能を提供します。
	 *
	 * この関数はPHPのmb_strwidth互換です。
	 *
	 * @param	String	str			丸め処理を行う文字列
	 * @param	int		start		切り取り開始位置
	 * @param	int		width		切り取りサイズ
	 * @param	String	trimmarker	切り取った後に追加する文字列
	 * @return	String	丸め処理を行った文字列
	 * @link	http://php.net/manual/ja/function.mb-strimwidth.php
	 */
	strImWidth : function (str, start, width, trimmarker) {
		//============================================
		// 初期化
		//============================================
		//トリムマーカーが未指定の場合は空文字として初期化
		if (trimmarker == null) {
			trimmarker = '';
		}

		var trimmarker_width = mb_strwidth(trimmarker);

		var stacker				= []
		var total_width			= 0;

		var current_char		= '';
		var current_char_code	= 0;
		var current_width		= 0;

		var next_char			= '';
		var next_char_code		= 0;
		var next_width			= 0;

		//============================================
		// mb_strimwidth互換 例外対応
		//============================================
		// 次の条件にマッチする場合、mb_strimwidthは常に空文字を返す。
		// ・対象文字列の1文字目のコードポイントが0x20以下または0x7E以上
		// ・トリムマーカーが空文字
		// ・対象文字列に特定のコードポイント（illegal_range_listにあるもの）内の文字が含まれる
		//
		// このブロックではそれの自動検知用の状態、値を定義する
		//============================================

		//コードポイントとトリムマーカーから例外対応有無を判定
		var irregular_caution		= (str.charCodeAt(0) < 0x21 || 0x7E < str.charCodeAt(0)) && trimmarker == '' && width == 1;

		//例外対応対象となる文字列のコードポイント定義
		//2次元目の配列の第一要素がコードポイント始点、第二要素がコードポイント終点
		//例）[0x1100, 0x115F]の場合
		// 0x1100 <= code_point && code_point <= 0x115F が例外対応対象のコードポイント範囲となる
		var illegal_range_list	= [
			[0x1100, 0x115F],
			[0x11A3, 0x11A7],
			[0x11FA, 0x11FF],
			[0x2329, 0x2329],
			[0x232A, 0x232A],
			[0x2E80, 0x2E99],
			[0x2E9B, 0x2EF3],
			[0x2F00, 0x2FD5],
			[0x2FF0, 0x2FFB],
			[0x3000, 0x303E],
			[0x3041, 0x3096],
			[0x3099, 0x30FF],
			[0x3105, 0x312D],
			[0x3131, 0x318E],
			[0x3190, 0x31BA],
			[0x31C0, 0x31E3],
			[0x31F0, 0x321E],
			[0x3220, 0x3247],
			[0x3250, 0x32FE],
			[0x3300, 0x4DBF],
			[0x4E00, 0xA48C],
			[0xA490, 0xA4C6],
			[0xA960, 0xA97C],
			[0xAC00, 0xD7A3],
			[0xD7B0, 0xD7C6],
			[0xD7CB, 0xD7FB],
			//サロゲートペア範囲も対象となるが、単体で渡す事自体がおかしいので仕様としては取り込まない
			[0xF900, 0xFAFF],
			[0xFE10, 0xFE19],
			[0xFE30, 0xFE52],
			[0xFE54, 0xFE66],
			[0xFE68, 0xFE6B],
			[0xFF01, 0xFF60],
			[0xFFE0, 0xFFE6],
			[0x1B000, 0x1B001],
			[0x1F200, 0x1F202],
			[0x1F210, 0x1F23A],
			[0x1F240, 0x1F248],
			[0x1F250, 0x1F251],
			[0x20000, 0x2FFFD],
			[0x30000, 0x3FFFD]
		];
		var illegal_range_length = illegal_range_list.length;

		/**
		 * 対象のコードポイントがmb_strimwidth互換 例外対応対象文字かどうか検証します。
		 *
		 * @param	int		char_code	コードポイント
		 * @return	bool	コードポイントがmb_strimwidth互換 例外対応対象文字の場合はtrue、そうでない場合はfalse
		 */
		var irregular_pattern			= function (char_code) {
			for (var i = 0; i < illegal_range_length;i++) {
				if (illegal_range_list[i][0] <= char_code && char_code <= illegal_range_list[i][1]) {
					return true;
				}
			}
			return false;
		};

		//============================================
		// 実処理
		//============================================
		for (var i = start, length = start + width;i < length;i++) {
			//現在の処理対象文字と次の文字をセットで取得する
			current_char_code	= str.charCodeAt(i);
			next_char_code		= str.charCodeAt(1 + i);

			//サロゲートペア対応
			if (0xD800 <= current_char_code && current_char_code <= 0xDBFF) {
				current_char_code = ((current_char_code - 0xD800) * 0x400) + (next_char_code - 0xDC00) + 0x10000;
				i++;
				next_char_code = str.charCodeAt(i + 1);
			}

			//次の文字のサロゲートペア対応
			if (0xD800 <= next_char_code && next_char_code <= 0xDBFF) {
				i++;
				next_char_code = ((next_char_code - 0xD800) * 0x400) + (str.charCodeAt(i + 1) - 0xDC00) + 0x10000;
			}

			//mb_strimwidth互換 例外対応
			if (irregular_caution) {
				if (irregular_pattern(current_char_code)) {
					return '';
				}
				if (irregular_pattern(next_char_code)) {
					return '';
				}
			}

			//全てのチェックを通過した上で数値として認識できない場合は落とす
			if (Number.isNaN(current_char_code)) {
				break;
			}

			//コードポイントをUTF-8文字に変換
			current_char = IckxSeIdeLib.prototype.fromChatCodeExt(current_char_code);

			//次の文字が存在しない場合は空文字を持つ
			next_char = Number.isNaN(next_char_code) ? '' : IckxSeIdeLib.prototype.fromChatCodeExt(next_char_code);

			//それぞれの文字幅を取得
			current_width		= mb_strwidth(current_char);
			next_width			= mb_strwidth(next_char);

			//現在までの文字列幅 + 次の文字の文字幅 + トリムマーカーの文字幅が指定幅より大きい場合は、トリムマーカーを付けて終了
			if (width < total_width + next_width + trimmarker_width) {
				stacker.push(trimmarker);
				break;
			}

			//現在までの文字列幅の更新
			total_width			+= current_width;

			//現在の文字を追加
			stacker.push(current_char);

			//現在の文字列幅が指定幅と同じかそれ以上の場合は落とす
			if (width <= total_width) {
				break;
			}
		}

		//============================================
		// 処理の終了
		//============================================
		//現在までに取得した文字を結合して返す
		return stacker.join('');
	},

	/**
	 * エレメントノードからxpathを構築します。
	 *
	 * @param	Node	element_node	xpath構築元のelement node
	 * @returns	element nodeまでのxpath
	 */
	getXpathByElementNode : function (element_node) {
		//============================================
		// 検証
		//============================================
		//対象とするノードタイプの設定 エレメントノードのみ対象とする
		var NODE_TYPE_ELEMENT_NODE = 1;

		//引数で渡されたノードが配列だった場合、先頭の1要素のみ使用する
		if (element_node instanceof Array) {
			element_node = element_node.shift();
		}

		//引数で渡されたノードがエレメントノードではない場合はエラーとする
		if (element_node.nodeType != NODE_TYPE_ELEMENT_NODE) {
			throw new ErrorException('渡されたノードがエレメントノードではありません。node_type:'+ element_node.nodeType +' node_name:'+ element_node.nodeName);
		}

		//============================================
		// 初期化
		//============================================
		var stacker = [];
		var node_name = '';
		var node_count = 0;
		var node_point = null;

		//============================================
		// 実処理：rootたる#documentに到達するまで登り続ける
		//============================================
		do {
			node_name = element_node.nodeName.toLowerCase();
			if (element_node.parentNode.children.length > 1) {
				node_count = 0;
				node_point = null;
				for (i = 0;i < element_node.parentNode.children.length;i++) {
					if (element_node.nodeName == element_node.parentNode.children[i].nodeName) {
						node_count++;
						if (element_node == element_node.parentNode.children[i]) {
							node_point = node_count;
						}
						if (node_point != null && node_count > 1) {
							node_name += '['+ node_point +']';
							break;
						}
					}
				}
			}
			stacker.unshift(node_name);
		} while ((element_node = element_node.parentNode) != null && element_node.nodeName != '#document');

		//============================================
		// 処理の終了
		//============================================
		return '/' + stacker.join('/').toLowerCase();
	},

	/**
	 * 開始エレメントノードに最も近い、探索するエレメント名を持つ親要素を返します。
	 *
	 * @param	Node	element_node	開始エレメントノード
	 * @param	String	node_name		探索するエレメント名
	 * @returns	Node	開始エレメントノードに最も近い、探索するエレメント名を持つ親要素 マッチ無しの場合はnull
	 */
	closest : function (element_node, node_name) {
		node_name = node_name.toLowerCase();
		var element_node = element_node.parentNode;
		for (;element_node;element_node = element_node.parentNode) {
			if (element_node.nodeName.toLowerCase() == node_name) {
				return element_node;
			}
		}
		return null;
	},

	/**
	 * 開始エレメントノードに最も近いtr要素な親要素を返します。
	 *
	 * @param	Node	element_node	開始エレメントノード
	 * @returns	Node	開始エレメントノードに最も近い、tr要素な親要素 マッチ無しの場合はnull
	 */
	closestTr : function (element_node) {
		return IckxSeIdeLib.prototype.closest(element_node, 'tr');
	},

	/**
	 * 指定された引数がエレメントノードかどうかを判定します。
	 *
	 * @param	mixed	arg	判定する変数
	 * @return	bool	指定された引数がエレメントノードの場合はtrue、そうでない場合はfalse
	 */
	isElementNode : function (arg) {
		return arg instanceof Node || arg instanceof Element;
	},

	/**
	 * エラー例外を構築します。
	 *
	 * @param	String	message		エラーメッセージ
	 * @param	String	exception	先行する例外がある場合はその例外
	 * @return	Error	エラー例外
	 */
	buildErrMsg : function (message, exception) {
		var message = [message];
		if (!exception) {
			message.push(exception);
		}
		return new Error(message.join("\n"));
	}
});

//==================================
//IckxSeIdeLib インスタンス化
//==================================
var ickx_se_ide_lib = new IckxSeIdeLib;

//==================================
//ICKX Selenium-IDE Extension
//==================================
var IckxSeIdeExt = classCreate();
objectExtend(IckxSeIdeExt.prototype, {
	//----------------------------------
	//Extend methods
	//----------------------------------
	/**
	 * PHPのmb_strimwidthと同様の機能を提供します。
	 *
	 * この関数はPHPのmb_strwidth互換です。
	 *
	 * @param	String	value	CSV形式として入力した引数
	 * 分割後はそれぞれ次の値となる
	 * 0 : string	丸め処理を行う文字列
	 * 1 : int		切り取り開始位置
	 * 2 : int		切り取りサイズ
	 * 3 : string	切り取った後に追加する文字列
	 * @return	String	丸め処理を行った文字列
	 * @see		IckxSeIdeLib.prototype.strImWidth()
 	 * @link	http://php.net/manual/ja/function.mb-strimwidth.php
	 */
	getImWidth : function (value) {
		var values = value.split(',');
		var str = values[0];
		var start = values[1];
		var width = values[2];
		var trimmarker = 3 in values ? values[3] : ';'

		return IckxSeIdeLib.prototype.strImWidth(str, start, width, trimmarker);
	},

	/**
	 * ロケ―ターで指定された要素の値を取得し、trimせずに返します。
	 *
	 * @param	String	locator	ロケ―ター
	 * @return	ロケ―ターで指定された要素のtrimされていない値
	 */
	getRealValue : function (locator) {
		return getInputValue(this.browserbot.findElement(locator));
	},

	/**
	 * ロケ―ターで指定された要素のテキストを取得し、trimせずに返します。
	 *
	 * @param	String	locator	ロケ―ター
	 * @return	ロケ―ターで指定された要素のtrimされていないテキスト
	 */
	getRealText : function (locator) {
		var element = this.browserbot.findElement(locator);

		var b = "";
		goog.userAgent.GECKO && "1.8" <= goog.userAgent.VERSION || goog.userAgent.WEBKIT || goog.userAgent.IE ? b = core.text.getTextContent_(element, !1) : element.textContent ? b = element.textContent : element.innerText && (b = element.innerText);
		b = core.text.normalizeNewlines_(b);
		b = core.text.normalizeSpaces_(b);
		return b;
	},

	/**
	 * ロケ―ターで指定された要素が属する直近のtr要素のXPathを取得します。
	 *
	 * @param	String	locator		ロケ―ター
	 * @return	String	要素が属する直近のtr要素のXPath tr要素が見つからない場合は空文字
	 */
	getClosestTrXpath : function (locator) {
		var element = IckxSeIdeLib.prototype.isElementNode(locator) ? locator : this.browserbot.findElement(selenium.preprocessParameter(locator)).parentNode;
		for (;element;element = element.parentNode) {
			if (element.nodeName.toLowerCase() == 'tr') {
				return IckxSeIdeLib.prototype.getXpathByElementNode(element);
			}
		}
		return '';
	},

	/**
	 * ロケ―ターで指定された要素が属するテーブル内での行数をストアします。
	 *
	 * @param	String	locator		ロケ―ター
	 * @param	String	store_name	取得した要素のストア名
	 */
	getRowIndex : function (locator, store_name) {
		var element = IckxSeIdeLib.prototype.isElementNode(locator) ? locator : this.browserbot.findElement(selenium.preprocessParameter(locator)).parentNode;
		for (;element;element = element.parentNode) {
			if (element.nodeName.toLowerCase() == 'tr') {
				storedVars[selenium.preprocessParameter(store_name)] = element.rowIndex + 1;
				return ;
			}
		}
		storedVars[selenium.preprocessParameter(store_name)] = 0;
	},

	/**
	 * ロケ―ターで指定された要素をストアします。
	 *
	 * @param	String	locator		ロケ―ター
	 * @param	String	store_name	取得した要素のストア名
	 */
	doGetElement : function (locator, store_name) {
		storedVars[selenium.preprocessParameter(store_name)] = this.browserbot.findElement(selenium.preprocessParameter(locator));
	},

	/**
	 * ロケ―ターで指定された要素のtextContentを返します。
	 *
	 * @param	String	locator		ロケ―ター
	 * @return	String	ロケ―ターで指定された要素のtextContent
	 */
	doStoreTextContent : function (locator) {
		return this.browserbot.findElement(locator).textContent;
	},

	/**
	 * ロケ―ターで指定された要素のinnerHTMLを返します。
	 *
	 * @param	String	locator		ロケ―ター
	 * @return	String	ロケ―ターで指定された要素のinnerHTML
	 */
	getInnerHtml : function (locator) {
		return this.browserbot.findElement(locator).innerHTML;
	},

	/**
	 * ロケ―ターで指定された要素のtrim済みinnerHTMLを返します。
	 *
	 * @param	String	locator		ロケ―ター
	 * @return	String	ロケ―ターで指定された要素のtrim済みinnerHTML
	 */
	getTrimmedInnerHtml : function (locator) {
		return this.browserbot.findElement(locator).innerHTML.trim();
	},

	/**
	 * 指定したストア名の値を取得します。
	 *
	 * @param	String	store_name	取得対象のストア名
	 * @return	String	値
	 */
	getVar : function (store_name) {
		return storedVars[selenium.preprocessParameter(store_name)];
	},

	/**
	 * ロケ―ターで指定された要素のテーブル内での行数を返します。
	 *
	 * @param	String	locator		ロケ―ター
	 * @return	String	ロケ―ターで指定された要素のテーブル内での行数
	 */
	getTableRowIndex : function (locator) {
		return this.browserbot.findElement(locator).rowIndex;
	},

	/**
	 * ロケ―ターで指定された要素のテーブル内での行数が奇数かどうかを返します。
	 *
	 * @param	String	locator		ロケ―ター
	 * @return	String	ロケ―ターで指定された要素のテーブル内での行数が奇数の場合は"true"、そうでない場合は"false"
	 */
	getTableRowIndexOdd : function (locator) {
		return this.getTableRowIndex(locator) % 2 != 0;
	},

	/**
	 * ロケ―ターで指定された要素のテーブル内での行数が奇数かどうかをストアします。
	 *
	 * 行数が奇数の場合は"true"、そうでない場合は"false"がストアされます。
	 *
	 * @param	String	locator		ロケ―ター
	 * @param	String	store_name	取得した要素のストア名
	 */
	doStoreFromTableRowIndexOdd : function (locator, parameters) {
		parameters = parameters.split(',');

		var store_name = selenium.preprocessParameter(parameters[0]);
		var odd_value = selenium.preprocessParameter(1 in parameters ? parameters[1] : '');
		var even_value = selenium.preprocessParameter(2 in parameters ? parameters[2] : '');
		var result = this.getTableRowIndexOdd(locator) ? odd_value : even_value;
		this._doExecCommand('store', result, store_name);
	},

	/**
	 * フィルタ関数をストアします。
	 *
	 * @param	function	filter_function		フィルタ関数
	 * @param	String		store_name			ストア名
	 */
	doSetFilter : function (filter_function, store_name) {
		storedVars[selenium.preprocessParameter(store_name)] = filter_function;
	},

	/**
	 * フィルタ関数を実行します。
	 *
	 * @param	function	filter_nane		フィルタ関数のストア名
	 * @param	String		store_name		フィルタ後の値のストア名
	 */
	doExecFilter : function (filter_name, store_name) {
		try {
			filter_name = selenium.preprocessParameter(filter_name);
			store_name = selenium.preprocessParameter(store_name);

			var store_names = store_name.split(',');
			store_name = store_names[0];
			target_store_name = 1 in store_names ? store_names[1] : store_name;
			var filter = eval('(function () {return '+ selenium.preprocessParameter(storedVars[filter_name]) +';})()');
			storedVars[target_store_name] = filter(storedVars[store_name]);
		} catch (e) {
			throw new SeleniumError("Threw an exception: " + extractExceptionMessage(e));
		}
	},

	/**
	 * Selenium-IDE Extension：HTML文中の改行文字を<br>タグに置換します。
	 *
	 * @param	String	html	置換対象のhtml文
	 * @return	String	改行文字置換後のhtml文
	 */
	doLf2Br : function (html) {
		return html.replace(/(?:\r?\n)/g, '<br>');
	},

	/**
	 * Selenium-IDE Extension：指定されたselectが現在選択しているindexを返します。
	 *
	 * このコマンドは単一選択時のみ利用可能です。
	 *
	 * @param	String	locator	ロケ―ター
	 * @return	String	指定されたselectが現在選択しているindex Selenium-IDE上での動きに合わせるため本来の値に+1して返される
	 */
	getSelectedIndex : function (locator) {
	    return this.browserbot.findElement(locator).selectedIndex + 1;
	},

	/**
 	 * Selenium-IDE Extension：指定されたロケ―ターにあるHTMLと指定した文字列の改行文字を<br>タグに変換した上で、HTMLとして検証を行います。
 	 *
	 * @param	String	locator	ロケ―ター
	 * @param	String	pattern	検証文字列
	 */
	assertAdjustLfHtml : function (locator, pattern) {
		var locator_text = this.doLf2Br(this.browserbot.findElement(locator).innerHTML);
		var pattern_text = this.doLf2Br(pattern);

	    if (locator_text != pattern_text) {
			Assert.fail("Actual value '"+ pattern_text +"' did not match '"+ locator_text +"'");
		}
	},

	/**
 	 * Selenium-IDE Extension：指定されたロケ―ターに指定した要素があるか検証します。
 	 *
	 * @param	String	locator	ロケ―ター
	 * @param	String	pattern	検証要素
	 */
	assertAttributePresent : function (locator, pattern) {
	    if (!this.browserbot.findElement(locator).hasAttribute(pattern)) {
			Assert.fail("Actual attribute '"+ pattern +"' did not found'");
		}
	},

	/**
 	 * Selenium-IDE Extension：指定されたロケ―ターに指定した要素がないか検証します。
 	 *
	 * @param	String	locator	ロケ―ター
	 * @param	String	pattern	検証要素
	 */
	assertAttributeNotPresent : function (locator, pattern) {
	    if (this.browserbot.findElement(locator).hasAttribute(pattern)) {
			Assert.fail("Actual attribute '"+ pattern +"' did found'");
		}
	},

	/**
 	 * Selenium-IDE Extension：指定されたロケ―ターにある要素を削除します。
 	 *
	 * @param	String	locator	削除対象要素へのロケ―ター
	 */
	doRemove : function (locator) {
		var element = this.browserbot.findElement(locator);
		element.parentNode.removeChild(element);
	},

	//----------------------------------
	//DOCTYPE宣言の検証
	//----------------------------------
	/**
	 * Selenium-IDE Extension：指定されたDOCTYPE宣言が行われているかどうか検証します。
	 *
	 * @param	String	doctype	DOCTYPE要素
	 */
	assertDocType : function (doctype) {
		var document = this.page().getDocument();

		if (document.doctype == null) {
			Assert.fail("DOCTYPE is undefined.");
		}

		var doctype_base = ['<!DOCTYPE'];
		if (document.doctype.name) {
			doctype_base.push(document.doctype.name);
		}
		if (document.doctype.publicId) {
			doctype_base.push('PUBLIC');
			doctype_base.push('"'+ document.doctype.publicId +'"');
		}
		if (document.doctype.systemID) {
			doctype_base.push('"'+ document.doctype.systemID +'"');
		}

		var target_doctype = doctype_base.join(' ') + '>';
		if (target_doctype.toLowerCase() != doctype.toLowerCase()) {
			Assert.fail("Actual doctype '"+ doctype.toLowerCase() +"' did not match '"+ target_doctype.toLowerCase() +"'");
		}
	},

	/**
	 * Selenium-IDE Extension：指定されたDOCTYPE名が設定されているかどうか検証します。
	 *
	 * @param	String	name	DOCTYPE名
	 */
	assertDocTypeName : function (name) {
		var document = this.page().getDocument();
		if (document.doctype == null) {
			Assert.fail("DOCTYPE is undefined.");
		}

		if (document.doctype.name.toLowerCase() != name.toLowerCase()) {
			Assert.fail("Actual doctype name '"+ document.doctype.name.toLowerCase() +"' did not match '"+ name.toLowerCase() +"'");
		}
	},

	/**
	 * Selenium-IDE Extension：指定されたDOCTYPE publicIdが設定されているかどうか検証します。
	 *
	 * @param	String	public_id	DOCTYPE publicId
	 */
	assertDocTypePublicId : function (public_id) {
		var document = this.page().getDocument();
		if (document.doctype == null) {
			Assert.fail("DOCTYPE is undefined.");
		}

		if (document.doctype.publicId != public_id) {
			Assert.fail("Actual doctype publicId '"+ document.doctype.publicId.toLowerCase() +"' did not match '"+ public_id.toLowerCase() +"'");
		}
	},

	/**
	 * Selenium-IDE Extension：指定されたDOCTYPE systemIdが設定されているかどうか検証します。
	 *
	 * @param	String	system_id	DOCTYPE systemId
	 */
	assertDocTypeSystemID : function (system_id) {
		var document = this.page().getDocument();
		if (document.doctype == null) {
			Assert.fail("DOCTYPE is undefined.");
		}

		if (document.doctype.systemID != system_id) {
			Assert.fail("Actual doctype systemID '"+ document.doctype.systemID.toLowerCase() +"' did not match '"+ system_id.toLowerCase() +"'");
		}
	},

	//----------------------------------
	//コマンドの実行
	//----------------------------------
	/**
	 * 拡張変数の事前展開を行い、返します。
	 *
	 * @param	String	text	展開対象の文字列
	 * @return	String	展開済みの文字列
	 */
	_preprocess : function (text) {
		var old = '';
		while (text != old) {
			old = text;
			text = selenium.preprocessParameter(text).replace(/\$_\{([^\}]+)\}/g, "${$1}");
		}
		return text;
	},

	/**
	 * ページopen時に変数展開を行ってから開きます。
	 *
	 * @param	String	url	URL
	 * @param	Object	ignoreResponseCode
	 */
	doOpenPreProcess : function (url, ignoreResponseCode) {
		var processed_url = this._preprocess(url);
		if (ignoreResponseCode == null || ignoreResponseCode.length == 0) {
			this.browserbot.ignoreResponseCode = true;
		} else if (ignoreResponseCode.toLowerCase() == "true") {
			this.browserbot.ignoreResponseCode = true;
		} else {
			this.browserbot.ignoreResponseCode = false;
		}

		this.browserbot.openLocation(processed_url);
		if (window["proxyInjectionMode"] == null || !window["proxyInjectionMode"]) {
			return this.makePageLoadCondition();
		}
	},

	/**
	 * コマンド一括実行時のログ表示を抑制します。
	 */
	doSetExeCommandSilentMode : function () {
		ickx_se_ide_lib.storedVars.inSilentMode = true;
	},

	/**
	 * コマンド一括実行時のログ表示を抑制を解除します。
	 */
	doReleaseExeCommandSilentMode : function () {
		ickx_se_ide_lib.storedVars.inSilentMode = false;
	},

	/**
	 * 現在のコマンド一括実行時のログ表示抑制状態を返します。
	 *
	 * @return	String	現在のログ表示抑制状態
	 */
	_inExecCommandSilentMode : function () {
		return ickx_se_ide_lib.storedVars.inSilentMode;
	},

	/**
	 * Selenium-IDE Extension：targetで指定した値をコマンドとし、valueで指定した値を引数としてコマンドを実行します。
	 *
	 * ！！注意！！
	 * 実行するコマンドが"verify*"の場合はverifyExecCommandを使用してください。
	 * doExecCommandおよびassertExecCommandで実行しエラーとなった場合、対象の"verify*"コマンドは"assert*"として振る舞います。
	 *
	 * @param	String	cmmand_name	実行するコマンド
	 * @param	String	values		CSV形式のコマンドに渡す引数 一つ目がtarget, 二つ目がvalue
	 * @return	mixed	コマンドの実行結果
	 */
	doExecCommand : function (command_name, values) {
		values = IckxSeIdeLib.prototype.purseCsv(values);
		values = 0 in values ? values[0] : [];
		return this._doExecCommand(command_name, 0 in values ? values[0] : '', 1 in values ? values[1] : '');
	},

	/**
	 * Selenium-IDE Extension：targetで指定した値をコマンドとし、valueで指定した値を引数として検証コマンドをアサーションとして実行します。
	 *
	 * @param	String	cmmand_name	実行するコマンド
	 * @param	String	values		CSV形式のコマンドに渡す引数 一つ目がtarget, 二つ目がvalue
	 * @return	mixed	コマンドの実行結果
	 */
	assertExecCommand : function (command_name, values) {
		values = IckxSeIdeLib.prototype.purseCsv(values);
		values = 0 in values ? values[0] : [];
		return this._doExecCommand(command_name, 0 in values ? values[0] : '', 1 in values ? values[1] : '');
	},

	//----------------------------------
	//ストア配列上の値からのコマンドの実行
	//----------------------------------
	/**
	 * Selenium-IDE Extension：ストアに保存された配列を元にコマンドを実行します。
	 *
	 * ！！注意！！
	 * verify*を実行する場合、verifyExecCommandFromArrayを使用してください。
	 * doExecCommandFromArrayおよびassertExecCommandFromArrayで実行し、"verify*"でエラーとなった場合、対象の"verify*"コマンドは"assert*"として振る舞います。
	 *
	 * @param	String	store_name	実行するdoExecCommand用のデータを保持した配列のストア名
	 * @throws	SeleniumError		未設定のストア名を指定された場合
	 */
	doExecCommandFromArray : function (store_name) {
		store_name = selenium.preprocessParameter(store_name);
		if (store_name in storedVars) {
			return this._doExecCommandFromArray(storedVars[store_name]);
		}
		throw new SeleniumError("Unknown store name: '" + store_name + "'");
	},

	/**
	 * Selenium-IDE Extension：ストアに保存された配列を元にコマンドを実行します。
	 *
	 * @param	String	store_name	実行するdoExecCommand用のデータを保持した配列のストア名
	 * @return	String	最後に実行されたコマンドの結果
	 */
	assertExecCommandFromArray : function (store_name) {
		return this.doExecCommandFromArray(store_name);
	},

	//----------------------------------
	//CSVファイルからのコマンド実行
	//----------------------------------
	/**
	 * Selenium-IDE Extension：CSVファイルに記載されたコマンドを一括で実行します。
	 *
	 * 1行につき1コマンドを実行できます。
	 * コマンドのフォーマットは次の通りとなります。
	 * コマンド,対象,値
	 * 例）
	 * "store","test_data","hogehoge"
	 *
	 * ！！注意！！
	 * verify*を実行する場合、verifyExecCommandFromCsvを使用してください。
	 * doExecCommandFromCsvおよびassertExecCommandFromCsvで実行し、"verify*"でエラーとなった場合、対象の"verify*"コマンドは"assert*"として振る舞います。
	 *
	 * @param	String	file_path	読込むCSVファイルのパス ファイルパスまたはXPATH形式のパスを指定してください
	 * @return	String	最後に実行されたコマンドの結果
	 */
	doExecCommandFromCsv : function (file_path) {
		return this._doExecCommandFromCsv(file_path, {skip_empty : true});
	},

	/**
	 * Selenium-IDE Extension：CSVファイルに記載されたコマンドをアサーションとして一括で実行します。
	 *
	 * 1行につき1コマンドを実行できます。
	 * コマンドのフォーマットは次の通りとなります。
	 * コマンド,対象,値
	 * 例）
	 * "open","http://www.google.com/",""
	 * "verifyTitle","Google",""
	 *
	 * アサーション以外のコマンドも使用できます。
	 *
	 * コマンド実行結果がエラーとなった場合、次の振る舞いを取ります。
	 * ・"assert*"
	 * 　処理継続不能なエラーとして例外を発生させます。
	 * ・"verify*"の場合
	 * 　verify*として呼び出されている場合は処理を継続させます。
	 * 　それ以外のdo*、assert*として呼び出されている場合は処理継続不能なエラーとして例外を発生させます。
	 * ・その他のコマンドの場合
	 * 　処理継続不能なエラーとして例外を発生させます。
	 *
	 * @param	String	file_path	読込むCSVファイルのパス ファイルパスまたはXPATH形式のパスを指定してください
	 * @return	String	最後に実行されたコマンドの結果
	 */
	assertExecCommandFromCsv : function (file_path) {
		return this.doExecCommandFromCsv(file_path);
	},

	//----------------------------------
	//拡張CSVファイルからのコマンド実行
	//----------------------------------
	/**
	 * Selenium-IDE Extension：拡張されたCSVファイルに記載されたコマンドを一括で実行します。
	 *
	 * ・CSVファイルの空行は無視されます。
	 * ・行頭が";"の場合、コメント行として無視されます。
	 *
	 * 1行につき1コマンドを実行できます。
	 * コマンドのフォーマットは次の通りとなります。
	 * コマンド,対象,値
	 * 例）
	 * "store","test_data","hogehoge"
	 *
	 * コメント行は次の通りとなります。
	 * ; ここはコメントですよ
	 *
	 * ！！注意！！
	 * verify*を実行する場合、verifyExecCommandFromExtCsvを使用してください。
	 * doExecCommandFromExtCsvおよびassertExecCommandFromExtCsvで実行し、"verify*"でエラーとなった場合、対象の"verify*"コマンドは"assert*"として振る舞います。
	 *
	 * @param	String	file_path	読込むCSVファイルのパス ファイルパスまたはXPATH形式のパスを指定してください
	 * @return	String	最後に実行されたコマンドの結果
	 */
	doExecCommandFromExtCsv : function (file_path) {
		return this._doExecCommandFromCsv(file_path, {skip_empty : true, row_comment : ';'});
	},

	/**
	 * Selenium-IDE Extension：拡張されたCSVファイルに記載されたコマンドを一括でログ出力無しで実行します。
	 *
	 * @param	String	file_path	読込むCSVファイルのパス ファイルパスまたはXPATH形式のパスを指定してください
	 * @return	String	最後に実行されたコマンドの結果
	 */
	doExecCommandFromExtCsvSilent : function (file_path) {
		this.doSetExeCommandSilentMode();
		var ret = this._doExecCommandFromCsv(file_path, {skip_empty : true, row_comment : ';'});
		this.doReleaseExeCommandSilentMode();
		return ret;
	},

	/**
	 * Selenium-IDE Extension：拡張されたCSVファイルに記載されたコマンドを一括で実行します。
	 *
	 * ・CSVファイルの空行は無視されます。
	 * ・行頭が";"の場合、コメント行として無視されます。
	 *
	 * 1行につき1コマンドを実行できます。
	 * コマンドのフォーマットは次の通りとなります。
	 * コマンド,対象,値
	 * 例）
	 * "open","http://www.google.com/",""
	 * "verifyTitle","Google",""
	 *
	 * アサーション以外のコマンドも使用できます。
	 *
	 * コメント行は次の通りとなります。
	 * ; ここはコメントですよ
	 *
	 * コマンド実行結果がエラーとなった場合、次の振る舞いを取ります。
	 * ・"assert*"
	 * 　処理継続不能なエラーとして例外を発生させます。
	 * ・"verify*"の場合
	 * 　verify*として呼び出されている場合は処理を継続させます。
	 * 　それ以外のdo*、assert*として呼び出されている場合は処理継続不能なエラーとして例外を発生させます。
	 * ・その他のコマンドの場合
	 * 　処理継続不能なエラーとして例外を発生させます。
	 *
	 * @param	String	file_path	読込むCSVファイルのパス ファイルパスまたはXPATH形式のパスを指定してください
	 * @return	String	最後に実行されたコマンドの結果
	 */
	assertExecCommandFromExtCsv : function (file_path) {
		return this.doExecCommandFromExtCsv(file_path);
	},

	//----------------------------------
	//拡張CSVファイルからの一括ストア
	//----------------------------------
	/**
	 * Selenium-IDE Extension：拡張されたCSVファイルに記載された値を一括でストアします。
	 *
	 * ・CSVファイルの空行は無視されます。
	 * ・行頭が";"の場合、コメント行として無視されます。
	 *
	 * @param	String	file_path	読込むCSVファイルのパス ファイルパスまたはXPATH形式のパスを指定してください
	 * @return	String	最後に実行したコマンドの結果
	 */
	doStoreFromExtCsv : function (file_path) {
		var csv_data = IckxSeIdeLib.prototype.csvLoad(selenium.preprocessParameter(file_path), {'skip_empty' : true, 'row_comment' : ';'});
		var result = null;

		for (var i = 0, length = csv_data.length;i < length;i++) {
			result = this._doExecCommand('store', csv_data[i][1], csv_data[i][0]);
		}

		return result;
	},

	//----------------------------------
	//CSVサポート
	//----------------------------------
	/**
	 * Selenium-IDE Extension：CSVファイルを配列化し、ストアします。
	 *
	 * @param	String	file_path	読込むCSVファイルのパス フルパスまたはXPATH形式のパスを指定してください。
	 */
	doStoreCsv : function (file_path, store_name) {
		storedVars[selenium.preprocessParameter(store_name)] = IckxSeIdeLib.prototype.csvLoad(selenium.preprocessParameter(file_path));
	},

	/**
	 * Selenium-IDE Extension：拡張されたCSVファイルを配列化し、ストアします。
	 *
	 * @param	String	file_path	読込む拡張されたCSVファイルのパス フルパスまたはXPATH形式のパスを指定してください。
	 */
	doStoreExtCsv : function (file_path, store_name) {
		storedVars[selenium.preprocessParameter(store_name)] = IckxSeIdeLib.prototype.csvLoad(selenium.preprocessParameter(file_path), {'skip_empty' : true, 'row_comment' : ';'});
	},

	/**
	 * Selenium-IDE Extension：拡張されたCSVファイルを配列化、値の展開を行ったのちストアします。
	 *
	 * @param	String	file_path	読込む拡張されたCSVファイルのパス フルパスまたはXPATH形式のパスを指定してください。
	 */
	doStoreExtCsvPreProcess : function (file_path, store_name) {
		storedVars[selenium.preprocessParameter(store_name)] = IckxSeIdeLib.prototype.csvLoad(selenium.preprocessParameter(file_path), {'skip_empty' : true, 'row_comment' : ';', 'preprocess' : function (node) {return selenium.preprocessParameter(node)}});
	},

	/**
	 * Selenium-IDE Extension：CSVファイルをロードします。
	 * ロードしたCSVファイルはグローバル変数の配列として保持します。
	 *
	 * @param	String	file_path	読込むCSVファイルのパス フルパスまたはXPATH形式のパスを指定してください。
	 */
	doLoadCsv : function (file_path) {
		IckxSeIdeLib = new IckxSeIdeLib;
		IckxSeIdeLib.csvInit(selenium.preprocessParameter(file_path));
	},

	/**
	 * Selenium-IDE Extension：指定したセルのデータをストアします。
	 *
	 * @param	String	position	取得対象のセルの座標 x,y形式で 0,0が原点となる
	 * @param	String	store_name	ストア先の変数名
	 */
	doStoreCsvCell : function (position, store_name) {
		var position = position.split(',');
		var row = position[0];
		var column = 0 in position ? position[0] : 0;
		this._doExecCommand('store', ickx_se_ide_lib.csvFetchCell(row, column), store_name);
	},

	/**
	 * Selenium-IDE Extension：CSVデータの行をeachして、データと行数をストアします。
	 *
	 * @param	String	position_store_name	行数のストア先の変数名
	 * @param	String	store_name			ストア先の変数名
	 */
	doEachCsvRow : function (position_store_name, store_name) {
		var csv_row_each = ickx_se_ide_lib.csvRowEach();
		if (csv_row_each == null) {
			csv_row_each = [null, null];
		}

		this._doExecCommand('store', csv_row_each[0], store_name);
		if (position_store_name) {
			this._doExecCommand('store', csv_row_each[1], position_store_name);
		}
	},

	/**
	 * Selenium-IDE Extension：CSVデータの現在の行から指定した列のデータをストアします。
	 *
	 * @param	String	column		取得対象の列
	 * @param	String	store_name	ストア先の変数名
	 */
	doFetchCellFromCurrentRow : function (column, store_name) {
		var current_row = ickx_se_ide_lib.csvCurrentRow();
		if (current_row == null) {
			this._doExecCommand('store', null, store_name);
		} else {
			this._doExecCommand('store', column in current_row ? current_row[column] : null, store_name);
		}
	},

	//----------------------------------
	//配列操作
	//----------------------------------
	/**
	 * Selenium-IDE Extension：添え字で指定された要素をストアします。
	 *
	 * @param	array	array_info	,で結合したストア名と添え字
	 * @param	array	store_name	保存先ストア名
	 */
	doStoreArrayColumn : function (array_info, store_name) {
		array_info = array_info.split(',');
		var array_store_name = array_info[0];
		var index = 1 in array_info ? array_info[1] : 0;
		return this._doExecCommand('store', array_store_name in storedVars && index in storedVars[array_store_name] ? storedVars[array_store_name][index] : null, store_name);
	},

	/**
	 * Selenium-IDE Extension：配列の各要素を一括でストアします。
	 *
	 * @param	array	array_info	,で結合したストア名と添え字 添え字を省略した場合は先頭から順に設定される
	 * @param	array	store_info	,で結合した保存先ストア名
	 */
	doListArrayColumn : function (array_info, store_info) {
		array_info = array_info.split(',');
		store_info = store_info.split(',');

		var array_store_name	= array_info.shift();
		var store_info_length	= store_info.length;
		if (array_info.length > store_info_length) {
			throw new SeleniumError("Missmatch index list: '" + array_store_name + "'");
		}

		if (!(array_store_name in storedVars)) {
			throw new SeleniumError("Array index not found: '" + array_store_name + "'");
		}
		var stored_array = storedVars[array_store_name];

		var target_index = null;
		for (var i = 0;i < store_info_length;i++) {
			target_index = i in array_info ? array_info[i] : i;

			if (!(target_index in stored_array)) {
				return null;
			}
			storedVars[store_info[i]] = stored_array[target_index]
		}

		return null;
	},

	//----------------------------------
	//テキスト検証
	//----------------------------------
	/**
	 * Selenium-IDE Extension：targetで指定された要素が持つcontentTextを元にassertionを行います。
	 *
	 * @param	String	locator	対象
	 * @param	String	value	値
	 */
	assertTextContent : function (locator, value) {
		var element = this.browserbot.findElement(locator);
		var text_content = element[typeof element.innerText === "undefined" ? 'textContent' : 'innerText'];

		value = value.replace(/(?:&nbsp;)/g, function(token) {
			return String.fromCharCode(160);
		});

		if (text_content.unescapeHTML == undefined ? text_content.unescapeHTML() != value : text_content != value) {
			Assert.fail("Actual value '"+ text_content +"' did not match '"+ value +"'");
		}
	},

	//----------------------------------
	//パスサポート
	//----------------------------------
	/**
	 * Selenium-IDE Extension：現在実行中のテストスイートファイルがあるフォルダパスをストアに保存します。
	 *
	 * @param	String	store_name	保存先ストア名
	 */
	doStoreCurrentTestSuiteFolder : function (store_name) {
		this._doExecCommand('store', IckxSeIdeLib.prototype.getCurrentTestSuiteFolder(), store_name);
	},

	/**
	 * Selenium-IDE Extension：現在実行中のテストスイートファイルのフルパスをストアに保存します。
	 *
	 * @param	String	store_name	保存先ストア名
	 */
	doStoreCurrentTestSuitePath : function (store_name) {
		this._doExecCommand('store', IckxSeIdeLib.prototype.getCurrentTestSuitePath(), store_name);
	},

	/**
	 * Selenium-IDE Extension：現在実行中のテストスイートファイルのファイル名をストアに保存します。
	 *
	 * @param	String	store_name	保存先ストア名
	 */
	doStoreCurrentTestSuiteFileName : function (store_name) {
		this._doExecCommand('store', IckxSeIdeLib.prototype.getCurrentTestSuiteFileName(), store_name);
	},
	/**
	 * Selenium-IDE Extension：現在実行中のテストケースファイルがあるフォルダパスをストアに保存します。
	 *
	 * @param	String	store_name	保存先ストア名
	 */
	doStoreCurrentTestCaseFolder : function (store_name) {
		this._doExecCommand('store', IckxSeIdeLib.prototype.getCurrentTestCaseFolder(), store_name);
	},

	/**
	 * Selenium-IDE Extension：現在実行中のテストケースファイルのフルパスをストアに保存します。
	 *
	 * @param	String	store_name	保存先ストア名
	 */
	doStoreCurrentTestCasePath : function (store_name) {
		this._doExecCommand('store', IckxSeIdeLib.prototype.getCurrentTestCasePath(), store_name);
	},

	/**
	 * Selenium-IDE Extension：現在実行中のテストケースファイルのファイル名をストアに保存します。
	 *
	 * @param	String	store_name	保存先ストア名
	 */
	doStoreCurrentTestCaseFileName : function (store_name) {
		this._doExecCommand('store', IckxSeIdeLib.prototype.getCurrentTestCaseFileName(), store_name);
	},

	/**
	 * Selenium-IDE Extension：配列によるforeachを開始します。
	 *
	 * @param	String	array_store_name	配列保存元ストア名
	 * @param	String	store_name			保存先ストア名
	 */
	doArrayEach : function (array_store_name, store_name) {
		var current_row = testCase.debugContext.debugIndex;
		var stacker_row = this._arrayEachStore.reverse_map[current_row];
		if (this._arrayEachStore.stacker[stacker_row].pointer == 0) {
			this._arrayEachStore.stacker[stacker_row].array_name = array_store_name;
			this._arrayEachStore.stacker[stacker_row].store_name = store_name;

			storedVars[selenium.preprocessParameter(store_name)] = storedVars[selenium.preprocessParameter(array_store_name)][this._arrayEachStore.stacker[stacker_row].pointer];
		}
	},

	/**
	 * Selenium-IDE Extension：配列によるforeachの終了位置です。
	 */
	doEndArrayEach : function () {
		var stacker_row = testCase.debugContext.debugIndex;

		var pointer = ++this._arrayEachStore.stacker[stacker_row].pointer;
		var stacker = this._arrayEachStore.stacker[stacker_row];

		if (pointer in storedVars[stacker.array_name]) {
			storedVars[selenium.preprocessParameter(stacker.store_name)] = storedVars[selenium.preprocessParameter(stacker.array_name)][pointer];
			this._arrayEachContinueFromRow(stacker.start_row);
		} else {
			this._arrayEachStore.stacker[stacker_row].pointer = 0;
		}
	},

	/**
	 * Selenium-IDE Extension：whileを開始します。
	 *
	 * @param	String	expr	終了条件用判定式
	 */
	doWhile : function (target) {
		var current_row = testCase.debugContext.debugIndex;
		var stacker_row = this._whileStore.reverse_map[current_row];
		this._whileStore.stacker[stacker_row].target = target;
	},

	/**
	 * Selenium-IDE Extension：whileの終了位置です。
	 */
	doEndWhile : function () {
		var stacker_row = testCase.debugContext.debugIndex;

		var pointer = ++this._whileStore.stacker[stacker_row].pointer;
		var stacker = this._whileStore.stacker[stacker_row];
		var target = this._whileStore.stacker[stacker_row].target;
		target = storedVars[selenium.preprocessParameter(target)];

		if (!eval(target)) {
			this._whileStore.stacker[stacker_row].expr = null;
		} else {
			this._whileContinueFromRow(stacker.start_row);
		}
	},

	//==================================
	//Utility
	//==================================
	/**
	 * コマンドファクトリーキャッシュ
	 *
	 * @return	CommandHandlerFactory	コマンドファクトリー
	 */
	_getCommandFactory : function () {
		if (ickx_se_ide_lib.storedVars.commandFactory == null) {
			ickx_se_ide_lib.storedVars.commandFactory = new CommandHandlerFactory();
			ickx_se_ide_lib.storedVars.commandFactory.initialize();
			ickx_se_ide_lib.storedVars.commandFactory.registerAll(selenium);
		}
		return ickx_se_ide_lib.storedVars.commandFactory;
	},

	/**
	 * コマンドを実行します。
	 *
	 * "verify*"以外で実行した場合で、実行するコマンドが"verify*"の場合、"assert*"として動作します。
	 * "open"、"waitFor*"、"*AndWait"などの一時停止が伴うコマンドは意図した順番通りに実行されません。
	 *
	 * @param	String	cmmand_name		実行するコマンド
	 * @param	String	target			対象
	 * @param	String	value			値
	 * @return	mixed	コマンドの実行結果
	 */
	_doExecCommand : function (command_name, target, value) {
		var command_name	= selenium.preprocessParameter(command_name);
		var target			= selenium.preprocessParameter(target);
		var value			= selenium.preprocessParameter(value);

		var command = new Command(command_name, target, value);
		var commandFactory = this._getCommandFactory();

		var handler = commandFactory.getCommandHandler(command.command);
		if (handler == null) {
			throw new SeleniumError("Unknown command: '" + command.command + "'");
		}

		if (!this._inExecCommandSilentMode()) {
			LOG.info("Executing: |" + command.command + " | " + command.target + " | " + command.value + " |");
		}

		var result = handler.execute(selenium, command);
		editor.health.increaseCounter('commands', command);

		if (result.failed && command_name.indexOf('verify') == 0) {
			Assert.fail(result.failureMessage);
		}

		return null;
	},

	/**
	 * 複数個のコマンドを実行します。
	 *
	 * "verify*"以外で実行した場合で、実行するコマンドが"verify*"の場合、"assert*"として動作します。
	 * "open"、"waitFor*"、"*AndWait"などの一時停止が伴うコマンドは意図した順番通りに実行されません。
	 *
	 * @param	Array	cmmands		実行するコマンド
	 * @param	String	最後に実行したコマンドの実行結果
	 */
	_doExecMultiCommand : function (commands) {
//		var commandFactory = new CommandHandlerFactory();
//		commandFactory.registerAll(selenium);
//
//		var localCommand = null;
//		var seleniumCommand = null;
//
//		var localCurrentTest = new IDETestLoop(commandFactory);
//		objectExtend(localCurrentTest, {
//			index : 0,
//			start : function () {
//				this.continueTest();
//			},
//			initialize: function(commandFactory, handler) {
//				this.handler = handler;
//			},
//			getCommandInterval : function () {
//				return 0;
//			},
//			nextCommand : function () {
//				if (!(this.index in commands)) {
//					return null;
//				}
//
//				localCommand = {
//					command	: commands[this.index][0],
//					target	: commands[this.index][1],
//					value	: commands[this.index][2]
//				};
//				LOG.info("Executing row number :"+ this.index);
//				this.index++;
//				seleniumCommand = new SeleniumCommand(localCommand.command, localCommand.target, localCommand.value);
//				return seleniumCommand;
//			},
//			commandComplete : function (result) {
//				if (result.failed) {
//					localCommand.result = 'failed';
//					editor.health.increaseCounter('commands', localCommand);
//				} else if (result.passed) {
//					localCommand.result = 'passed';
//				} else {
//					localCommand.result = 'done';
//				}
//			},
//			commandError : function () {
//				localCommand.result = 'failed';
//				editor.health.increaseCounter('commands', localCommand);
//				this.index = -1;
//			},
//			testComplete : function () {
//				editor.health.increaseCounter('commands', localCommand);
//			}
//		});
//		localCurrentTest.start();
		var result = null;

		if (this._inExecCommandSilentMode()) {
			for (var i = 0, length = commands.length;i < length;i++) {
				result = this._doExecCommand(commands[i][0], commands[i][1], commands[i][2]);
			}
		} else {
			for (var i = 0, length = commands.length;i < length;i++) {
				LOG.info("Executing row number :"+ i);
				result = this._doExecCommand(commands[i][0], commands[i][1], commands[i][2]);
			}
		}

		return result;
	},

	/**
	 * CSVファイルに記載されたコマンドを一括で実行します。
	 *
	 * コマンド実行結果がエラーとなった場合、次の振る舞いを取ります。
	 * ・"assert*"
	 * 　処理継続不能なエラーとして例外を発生させます。
	 * ・"verify*"の場合
	 * 　verify*として呼び出されている場合は処理を継続させます。
	 * 　それ以外のdo*、assert*として呼び出されている場合は処理継続不能なエラーとして例外を発生させます。
	 * ・その他のコマンドの場合
	 * 　処理継続不能なエラーとして例外を発生させます。
	 *
	 * @param	String	file_path	読込むCSVファイルのパス フルパスまたはXPATH形式のパスを指定してください
	 * @return	String	コマンドの実行結果
	 */
	_doExecCommandFromCsv : function (file_path, options) {
		return this._doExecMultiCommand(IckxSeIdeLib.prototype.csvLoad(selenium.preprocessParameter(file_path), options));
	},

	/**
	 * 配列を元にコマンドを実行します。
	 *
	 * @param	Array	実行するdoExecCommand用のデータを保持した配列
	 * @return	String	コマンドの実行結果
	 */
	_doExecCommandFromArray : function (array) {
		return this._doExecCommand(0 in array ? array[0] : '', 1 in array ? array[1] : '', 2 in array ? array[2] : '');
	},

	/**
	 * arrayEach用ストア
	 */
	_arrayEachStore : {
		enable		: false,
		stacker		: {},
		reverse_map	: {}
	},

	/**
	 * arrayEach用初期化処理
	 */
	_arrayEachInit : function () {
		//初期化開始
		this._arrayEachStore = {
			enable		: true,
			stacker		: {},
			reverse_map	: {}
		};

		var stacker = {};
		var commands = testCase.commands;
		var commands_length = commands.length;
		var command = null;

		var loop_check_row_stacker = [];
		var loop_check_row = null;

		for (var i = commands_length - 1;0 <= i;i--) {
			command = commands[i];
			if (command.type != 'command') {
				continue;
			}

			switch (command.command.toLowerCase()) {
				case "endarrayeach":
					loop_check_row = i;
					loop_check_row_stacker.push(loop_check_row);
					stacker[loop_check_row] = {
						start_row	: null,
						array_name	: null,
						store_name	: null,
						pointer		: 0
					};
					break;
				case "arrayeach":
					loop_check_row = loop_check_row_stacker.pop();
					stacker[loop_check_row].start_row = i;
					break;
			}
		}

		var stacker_reverse_map = {};
		for (var index in stacker) {
			stacker_reverse_map[stacker[index].start_row] = index;
		}

		this._arrayEachStore.stacker		= stacker;
		this._arrayEachStore.reverse_map	= stacker_reverse_map;
	},

	/**
	 * arrayEach用復帰処理
	 *
	 * @param	String	復帰先行番号
	 */
	_arrayEachContinueFromRow : function (row_num) {
		if(row_num == undefined || row_num == null || row_num < 0) {
			throw new SeleniumError("Invalid row_num specified. row:"+ row_num);
		}
		testCase.debugContext.debugIndex = row_num;
	},

	/**
	 * while用ストア
	 */
	_whereStore : {
		enable		: false,
		stacker		: {},
		reverse_map	: {}
	},

	/**
	 * while用初期化処理
	 */
	_whileInit : function () {
		//初期化開始
		this._whileStore = {
			enable		: true,
			stacker		: {},
			reverse_map	: {}
		};

		var stacker = {};
		var commands = testCase.commands;
		var commands_length = commands.length;
		var command = null;

		var loop_check_row_stacker = [];
		var loop_check_row = null;

		for (var i = commands_length - 1;0 <= i;i--) {
			command = commands[i];
			if (command.type != 'command') {
				continue;
			}

			switch (command.command.toLowerCase()) {
				case "endwhile":
					loop_check_row = i;
					loop_check_row_stacker.push(loop_check_row);
					stacker[loop_check_row] = {
						start_row	: null,
						array_name	: null,
						store_name	: null,
						target		: null
					};
					break;
				case "while":
					loop_check_row = loop_check_row_stacker.pop();
					stacker[loop_check_row].start_row = i;
					break;
			}
		}

		var stacker_reverse_map = {};
		for (var index in stacker) {
			stacker_reverse_map[stacker[index].start_row] = index;
		}

		this._whileStore.stacker		= stacker;
		this._whileStore.reverse_map	= stacker_reverse_map;
	},

	/**
	 * while用復帰処理
	 *
	 * @param	String row_num	復帰先行番号
	 */
	_whileContinueFromRow : function (row_num) {
		if(row_num == undefined || row_num == null || row_num < 0) {
			throw new SeleniumError("Invalid row_num specified. row:"+ row_num);
		}
		testCase.debugContext.debugIndex = row_num;
	},

	/**
	 * リセット時の処理リスト
	 */
	_resetList : [
		'_arrayEachInit',
		'_whileInit',
	],

	/**
	 * リセット処理拡張
	 */
	resetExt : function () {
		for (var i = 0;i < this._resetList.length;i++) {
			this[this._resetList[i]]();
		}
	},

	/**
	 * リセット
	 *
	 * @overwrite
	 * @see	Selenium.reset()
	 */
	reset : function () {
		this.defaultTimeout = Selenium.DEFAULT_TIMEOUT;
		// todo: this.browserbot.reset()
		this.browserbot.selectWindow("null");
		this.browserbot.resetPopups();

		this.resetExt();
	}
});

/**
 * 全do*, get* assert*メソッドにPreProcess版を設定
 */
for (method_name in IckxSeIdeExt.prototype) {
	if (method_name.match(/^(?:do|get|assert)/) && method_name.match(/PreProcess$/) === null && IckxSeIdeExt.prototype[method_name].length > 0) {
		IckxSeIdeExt.prototype[method_name + 'PreProcess'] = function (target, value) {
			return IckxSeIdeExt.prototype[method_name](Selenium.prototype._preprocess(target), Selenium.prototype._preprocess(value));
		};
	}
}

for (method_name in Selenium.prototype) {
	if (method_name.match(/^(?:do|get|assert)/) && method_name.match(/PreProcess$/) === null && Selenium.prototype[method_name].length > 0) {
		Selenium.prototype[method_name + 'PreProcess'] = function (target, value) {
			return Selenium.prototype[method_name](Selenium.prototype._preprocess(target), Selenium.prototype._preprocess(value));
		};
	}
}

/**
 * Seleniumを拡張する
 */
objectExtend(Selenium.prototype, IckxSeIdeExt.prototype);
